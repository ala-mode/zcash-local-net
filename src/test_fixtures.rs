//! Test fixtures for running client RPC tests from external crates
//!
//! For validator/indexer development, the struct must be added to this crate (validator.rs / indexer.rs)
//! and the test fixtures must be expanded to include the additional process
//!
//! If running test fixtures from an external crate, the chain cache should be generated by running
//! `generate_chain_cache` which will cache the chain in a `CARGO_MANIFEST_DIR/chain_cache/client_rpcs` directory
//!
//! ```ignore(incomplete)
//! #[ignore = "not a test. generates chain cache for client_rpc tests."]
//! #[tokio::test]
//! async fn generate_zcashd_chain_cache() {
//!   tracing_subscriber::fmt().init();
//!
//!   zcash_local_net::test_fixtures::generate_zcashd_chain_cache(
//!     ZCASHD_BIN,
//!     ZCASH_CLI_BIN,
//!     LIGHTWALLETD_BIN,
//!   )
//!   .await;
//! }
//! ```

use std::path::PathBuf;

use zcash_client_backend::proto;
use zcash_protocol::{PoolType, ShieldedProtocol};
use zingolib::{
    testutils::lightclient::{from_inputs, get_base_address},
    testvectors::REG_O_ADDR_FROM_ABANDONART,
};

use crate::{
    client,
    indexer::{Indexer as _, Lightwalletd, LightwalletdConfig, Zainod, ZainodConfig},
    network, utils,
    validator::{Validator as _, Zcashd, ZcashdConfig},
    LocalNet,
};

/// Generates zcashd chain cache for client RPC test fixtures
pub async fn generate_zcashd_chain_cache(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let mut local_net = LocalNet::<Lightwalletd, Zcashd>::launch(
        LightwalletdConfig {
            lightwalletd_bin,
            listen_port: None,
            validator_conf: PathBuf::new(),
        },
        ZcashdConfig {
            zcashd_bin,
            zcash_cli_bin,
            rpc_port: None,
            activation_heights: network::ActivationHeights::default(),
            miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
            chain_cache: None,
        },
    );

    local_net.validator().generate_blocks(2).unwrap();

    let lightclient_dir = tempfile::tempdir().unwrap();
    let (faucet, recipient) = client::build_lightclients(
        lightclient_dir.path().to_path_buf(),
        local_net.indexer().port(),
    )
    .await;

    // TODO: use second recipient taddr
    // recipient.do_new_address("ozt").await.unwrap();
    // let recipient_addresses = recipient.do_addresses().await;
    // recipient taddr child index 0:
    // tmFLszfkjgim4zoUMAXpuohnFBAKy99rr2i
    //
    // recipient taddr child index 1:
    // tmAtLC3JkTDrXyn5okUbb6qcMGE4Xq4UdhD
    //
    // faucet taddr child index 0:
    // tmBsTi2xWTjUdEXnuTceL7fecEQKeWaPDJd

    faucet.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            100_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            100_000,
            Some("sapling test memo"),
        )],
    )
    .await
    .unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Transparent).await,
            100_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).unwrap();

    recipient.do_sync(false).await.unwrap();
    recipient.quick_shield().await.unwrap();
    local_net.validator().generate_blocks(1).unwrap();

    faucet.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Transparent).await,
            200_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).unwrap();

    recipient.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&faucet, PoolType::Transparent).await,
            10_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).unwrap();

    recipient.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &recipient,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Orchard)).await,
            10_000,
            Some("orchard test memo"),
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(2).unwrap();

    faucet.do_sync(false).await.unwrap();
    from_inputs::quick_send(
        &faucet,
        vec![(
            &get_base_address(&recipient, PoolType::Shielded(ShieldedProtocol::Sapling)).await,
            100_000,
            None,
        )],
    )
    .await
    .unwrap();
    local_net.validator().generate_blocks(1).unwrap();

    let chain_cache_dir = utils::chain_cache_dir();
    if !chain_cache_dir.exists() {
        std::fs::create_dir_all(chain_cache_dir.clone()).unwrap();
    }
    local_net
        .validator_mut()
        .cache_chain(chain_cache_dir.join("client_rpc_tests"));
}

/// GetLightdInfo RPC test
pub async fn get_lightd_info(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        validator_conf: zcashd.config_path(),
    })
    .unwrap();

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::Empty {});
    let zainod_response = zainod_client
        .get_lightd_info(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::Empty {});
    let lwd_response = lwd_client
        .get_lightd_info(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetLightdInfo responses...");

    println!("\nZainod response:");
    println!("taddr support: {}", zainod_response.taddr_support);
    println!("chain name: {}", zainod_response.chain_name);
    println!(
        "sapling activation height: {}",
        zainod_response.sapling_activation_height
    );
    println!(
        "consensus branch id: {}",
        zainod_response.consensus_branch_id
    );
    println!("block height: {}", zainod_response.block_height);
    println!("estimated height: {}", zainod_response.estimated_height);
    println!("zcashd build: {}", zainod_response.zcashd_build);
    println!("zcashd subversion: {}", zainod_response.zcashd_subversion);

    println!("\nLightwalletd response:");
    println!("taddr support: {}", lwd_response.taddr_support);
    println!("chain name: {}", lwd_response.chain_name);
    println!(
        "sapling activation height: {}",
        lwd_response.sapling_activation_height
    );
    println!("consensus branch id: {}", lwd_response.consensus_branch_id);
    println!("block height: {}", lwd_response.block_height);
    println!("estimated height: {}", lwd_response.estimated_height);
    println!("zcashd build: {}", lwd_response.zcashd_build);
    println!("zcashd subversion: {}", lwd_response.zcashd_subversion);

    println!("");

    assert_eq!(zainod_response.taddr_support, lwd_response.taddr_support);
    assert_eq!(zainod_response.chain_name, lwd_response.chain_name);
    assert_eq!(
        zainod_response.sapling_activation_height,
        lwd_response.sapling_activation_height
    );
    assert_eq!(
        zainod_response.consensus_branch_id,
        lwd_response.consensus_branch_id
    );
    assert_eq!(zainod_response.block_height, lwd_response.block_height);
    assert_eq!(
        zainod_response.estimated_height,
        lwd_response.estimated_height
    );
    assert_eq!(zainod_response.zcashd_build, lwd_response.zcashd_build);
    assert_eq!(
        zainod_response.zcashd_subversion,
        lwd_response.zcashd_subversion
    );
}

/// GetLatestBlock RPC test
pub async fn get_latest_block(
    zcashd_bin: Option<PathBuf>,
    zcash_cli_bin: Option<PathBuf>,
    zainod_bin: Option<PathBuf>,
    lightwalletd_bin: Option<PathBuf>,
) {
    let zcashd = Zcashd::launch(ZcashdConfig {
        zcashd_bin,
        zcash_cli_bin,
        rpc_port: None,
        activation_heights: network::ActivationHeights::default(),
        miner_address: Some(REG_O_ADDR_FROM_ABANDONART),
        chain_cache: Some(utils::chain_cache_dir().join("client_rpc_tests")),
    })
    .unwrap();
    let zainod = Zainod::launch(ZainodConfig {
        zainod_bin,
        listen_port: None,
        validator_port: zcashd.port(),
    })
    .unwrap();
    let lightwalletd = Lightwalletd::launch(LightwalletdConfig {
        lightwalletd_bin,
        listen_port: None,
        validator_conf: zcashd.config_path(),
    })
    .unwrap();

    let mut zainod_client = client::build_client(network::localhost_uri(zainod.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::ChainSpec {});
    let zainod_response = zainod_client
        .get_latest_block(request)
        .await
        .unwrap()
        .into_inner();

    let mut lwd_client = client::build_client(network::localhost_uri(lightwalletd.port()))
        .await
        .unwrap();
    let request = tonic::Request::new(proto::service::ChainSpec {});
    let lwd_response = lwd_client
        .get_latest_block(request)
        .await
        .unwrap()
        .into_inner();

    println!("Asserting GetLatestBlock responses...");

    println!("\nZainod response:");
    println!("block id: {:?}", zainod_response);

    println!("\nLightwalletd response:");
    println!("block id: {:?}", lwd_response);

    println!("");

    assert_eq!(zainod_response, lwd_response);
}
